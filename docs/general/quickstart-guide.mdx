---
title: 'Quickstart Guide'
---

## Summary

This walkthrough demonstrates how to perform a swap of USDC on Noble to TIA on Celestia using the Skip Go Client .

 <Note>
 **Having trouble? Get in touch!**

Please reach out if you believe the client does not support your desired user experience or are unsure of how to use it.
Join [our Discord](https://skip.build/discord) and select the "Skip Go Developer" role.

</Note>


## Example using @skip-go/client package

This example is for browser environments.

### 1\. Install @skip-go/client

In your command line terminal, install the `@skip-go/client` package:

```Shell shell
npm i @skip-go/client
```

<Info>
 **Additional dependencies and steps will be required for EVM & SVM Transactions**

This example constructs a cross-chain swap between 2 Cosmos chains, but Skip Go API supports all major EVM chains & Solana. (See [Supported Ecosystems](/supported-ecosystems-and-bridges) for more info about which chains, routes, and tokens we support)

If you'd like to perform a cross-chain swap that starts or ends on Solana or an EVM chain, you'll need to import additional dependencies and configure additional tx signers. After going through this tutorial, check out [EVM Transactions Intro](/evm-transactions) and [SVM Transactions Intro](/svm-transaction-details) if you need.

</Info>

### 2\. Setup Signers

Optionally, you can set up a signer for each EVM, SVM, or Cosmos SDK ecosystems.

For EVM transactions, You need to install the `viem` package:

```Shell shell
npm i viem
```

For SVM transactions, You can pick which wallets you want to use in [@solana/wallet-adapter-wallets](https://github.com/anza-xyz/wallet-adapter/blob/master/PACKAGES.md#wallets).
For this example, we are going to use Phantom wallet:

```Shell shell
npm i @solana/wallet-adapter-phantom
```

Now, let's create the SkipClient instance with the signers for each ecosystem!

We are going to use Keplr for Cosmos transactions, MetaMask for EVM transactions, and Phantom for Solana transactions. Note that only a Cosmos signer is required for this example.

```ts
import { SkipClient } from "@skip-router/client";
import { PhantomWalletAdapter } from "@solana/wallet-adapter-phantom";
import { createWalletClient } from "viem";

const skipClient = new SkipClient({
    getCosmosSigner: async (chainID) => {
        const offlineSigner = window.keplr?.getOfflineSigner(chainID);
        if (!offlineSigner) throw new Error("Keplr not installed");
        return offlineSigner;
    },
    // optional for this example
    getEVMSigner: async () => {
        const ethereum = window.ethereum;
        if (!ethereum) throw new Error("MetaMask not installed");
        const client = createWalletClient({
        chain: mainnet,
        transport: custom(window.ethereum),
        });
        return client;
    },
      // optional for this example
    getSVMSigner: async () => {
        const phantom = new PhantomWalletAdapter();
        return phantom;
    }
});
```

### 3\. Request a Quote

Now, we can use the `SkipClient.route` function to request a quote & route to swap USDC on Noble to TIA on Celestia:

Just add the following line after the line where you initialized the skipClient:

```ts
const route = await skipClient.route({
  sourceAssetDenom: 'uusdc',
  sourceAssetChainID: 'noble-1',
  destAssetDenom: 'utia',
  destAssetChainID: 'celestia',
  amountIn: '1000000', // 1 uusdc
  smartSwapOptions: {
    splitRoutes: true,
  },
});
```

<Info>
 **Understanding the Route Response**

The route response contains important information about the swap process. Key outputs include:

- **`amountOut`**: The estimated amount the user will receive after the swap, net of all fees and price impact
- **`requiredChainAddresses`**: Chain IDs where you need to provide user addresses when generating the transaction
- **`operations`**: Steps involved in moving from the source to the destination token

For more details, see the [/v2/fungible/route](/api-reference/getroutev2) reference docs.

</Info>

 <Note>
**Adding a fee for yourself**

You can your set your own swap fee by setting `cumulativeAffiliateFeeBPS` to the total fee amount you want to collect from the user, measured in hundredths of a percent (aka "bips").

Learn more about [setting affilate fees](/affiliate-fees)

</Note>
### 4\. Get Required Addresses

Now that we have the route response, we can use our signer to get the list of chains where the user or reeceiver addresses are required for executing the route.

We'll use these addresses in the next step to populate `userAddresses` when executing the route with the `SkipClient.executeRoute` method.

The `requiredChainAddresses` field in the output of `route` gives the chainIDs we need to use.

<Warning>
**Do Not Derive Addresses Across Chains**

Always request the user address from the corresponding wallet or signer for each chain. Do not attempt to derive an address on one chain from an address on another chain. This can result in addresses the user cannot sign for, especially if the chains use different address derivation methods.

For more details on handling cross-chain failures, see [Cross-chain Failure Cases](../advanced-transfer/handling-cross-chain-failure-cases).
</Warning>


It's recommended you keep the address somewhere and have function to get the address from the chainID. In this example we have a function called `getAddress` that takes the chainID and returns the address.

Add the following snippet to your script after getting the route to retrieve the address associated with each `requiredChainAddresses` entry:

```ts
const userAddresses = route.requiredChainAddresses.map(chainID => {
  // The userAddresses array must have the same order and length as requiredChainAddresses
  return {
    chainID: chainID,
    address: getAddress(chainID),
  };
});

```

<Warning>
 **Never attempt to derive an address on one chain from an address on another chain**

Whenever you need a user address, please request it from the corresponding wallet / signer. Do not attempt to use bech32 cross-chain derivation.

If you attempt to derive an address on one chain from an address on another chain, you may derive an address that the user cannot actually sign for if the two chains have different address-derivation processes. For example, if you derive a Cosmos address from an Ethereum address, you will get an address that the user cannot sign for and cannot use.

</Warning>

### 5\. Execute the route!

Finally, use the `SkipClient.executeRoute` method to create, sign, submit, and track the transaction.

Include optional callbacks on broadcast, track and completion to update your UI as the transaction progresses.

```ts
await skipClient.executeRoute({
  route,
  userAddresses,
  // Executes after all of the operations triggered by a user's signature complete.
  // For multi-tx routes that require multiple user signatures, this will be called once for each tx in sequence
  onTransactionCompleted: (chainID, txHash, status) => {
    console.log(
      `Route completed with tx hash: ${txHash} & status: ${status.state}`
    );
  },
  // called after the transaction that the user signs gets broadcast on chain
  onTransactionBroadcast: ({ txHash, chainID }) => {
    console.log(`Transaction broadcasted with tx hash: ${txHash}`);
  },
  // called after the transaction that the user signs is successfully registered for tracking
  onTransactionTracked: ({ txHash, chainID }) => {
    console.log(`Transaction tracked with tx hash: ${txHash}`);
  },
});
```

Once the transaction is complete, you'll have new TIA in your Celestia address!

 <Check>
**Need Help or Have Feedback?**

Join [our Discord](https://skip.build/discord) and select the "Skip Go Developer" role to share your questions and feedback.

 </Check>
