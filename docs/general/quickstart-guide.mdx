---
title: 'Quickstart Guide'
---

## Summary

This walkthrough demonstrates how to perform a swap of USDC on Noble to TIA on Celestia using the Skip Go Client in a browser environment.

## Prerequisites

- **Node.js and npm** installed on your machine.
- Basic knowledge of **TypeScript**.
- Familiarity with **Cosmos wallets**, specifically **Keplr**.

 <Note>
 **Having trouble? Get in touch!**

Please reach out if Skip Go doesn't support your desired user experience or are unsure of how to use it.
Join [our Discord](https://skip.build/discord) and select the "Skip Go Developer" role.

</Note>

### 1\. Install @skip-go/client

In your command line terminal, install the `@skip-go/client` package:

```Shell shell
npm i @skip-go/client
```

<Info>
 **EVM and SVM transactions**

This example constructs a cross-chain swap between 2 Cosmos chains, but Skip Go supports all major EVM chains & Solana. See [Supported Ecosystems](./supported-ecosystems-and-bridges), [EVM Transactions](../advanced-transfer/evm-transactions) and [SVM Transactions](../advanced-transfer/svm-transaction-details) for more information.

</Info>

### 2\. Setup Signers

Optionally, you can set up a signer for each EVM, SVM, or Cosmos SDK ecosystems.

For EVM transactions, You need to install the `viem` package:

```Shell shell
npm i viem
```

For SVM transactions, You can pick which wallets you want to use in [@solana/wallet-adapter-wallets](https://github.com/anza-xyz/wallet-adapter/blob/master/PACKAGES.md#wallets).
For this example, we are going to use Phantom wallet:

```Shell shell
npm i @solana/wallet-adapter-phantom
```

Now, let's create the `SkipClient` instance with signers for each ecosystem!

We're going to use Keplr for Cosmos transactions, MetaMask for EVM transactions, and Phantom for Solana transactions. 
Note that only a Cosmos signer is required for this example.

```ts
import { SkipClient } from "@skip-router/client";
import { PhantomWalletAdapter } from "@solana/wallet-adapter-phantom";
import { createWalletClient } from "viem";
import { mainnet } from "viem/chains";

const skipClient = new SkipClient({
    getCosmosSigner: async (chainID) => {
        const offlineSigner = window.keplr?.getOfflineSigner(chainID);
        if (!offlineSigner) throw new Error("Keplr not installed");
        return offlineSigner;
    },
    // optional for this example
    getEVMSigner: async () => {
        const ethereum = window.ethereum;
        if (!ethereum) throw new Error("MetaMask not installed");
        const client = createWalletClient({
          chain: mainnet,
          transport: custom(window.ethereum),
        });
        return client;
    },
    // optional for this example
    getSVMSigner: async () => {
        const phantom = new PhantomWalletAdapter();
        return phantom;
    }
});
```

### 3\. Request a Quote

Now, we can use the `SkipClient.route` function to request a quote & route to swap USDC on Noble to TIA on Celestia.

After initializing your `skipClient` add the following::

```ts
const route = await skipClient.route({
  sourceAssetDenom: 'uusdc',
  sourceAssetChainID: 'noble-1',
  destAssetDenom: 'utia',
  destAssetChainID: 'celestia',
  amountIn: '1000000', // 1 uusdc
  smartSwapOptions: {
    splitRoutes: true,
  },
});

```

<Info>
 **Understanding the Route Response**

The route response contains important information about the swap process. Key outputs include:

- **`amountOut`**: The estimated amount the user will receive after the swap, net of all fees and price impact
- **`requiredChainAddresses`**: Chain IDs where you need to provide user addresses when generating the transaction
- **`operations`**: Steps involved in moving from the source to the destination token

For more details, see the [/v2/fungible/route](/api-reference/getroutev2) reference docs.

</Info>

 <Note>
**Adding a fee for yourself**

You can your set your own swap fee by setting `cumulativeAffiliateFeeBPS` to the total fee amount you want to collect from the user, measured in hundredths of a percent (aka "bips").

Learn more about [setting affilate fees](/affiliate-fees)

</Note>
### 4\. Get Required Addresses

With the route response available, we can now use our signer to retrieve the list of chains where user or receiver addresses are required to execute the route.

We'll use these addresses in the next step to populate `userAddresses` when executing the route with the `SkipClient.executeRoute` method.

The `requiredChainAddresses` field in the output of `route` gives the chainIDs we need to use.

<Warning>
**Do Not Derive Addresses Across Chains**

Always request the user address from the corresponding wallet or signer for each chain. Do not attempt to derive an address on one chain from an address on another chain. This can result in addresses the user cannot sign for, especially if the chains use different address derivation methods.

For more details on handling cross-chain failures, see [Cross-chain Failure Cases](../advanced-transfer/handling-cross-chain-failure-cases).
</Warning>


We recommend storing the user's addresses and creating a function like getAddress that retrieves the address based on the chain ID.

Add the following snippet to your script after getting the route to retrieve the address associated with each `requiredChainAddresses` entry:

```ts
const userAddresses = route.requiredChainAddresses.map(chainID => {
  // The userAddresses array must have the same order and length as requiredChainAddresses
  return {
    chainID: chainID,
    address: getAddress(chainID),
  };
});

```

<Warning>
 **Never attempt to derive an address on one chain from an address on another chain**

Whenever you need a user address, please request it from the corresponding wallet or signer. Do not attempt to use bech32 cross-chain derivation.

If you attempt to derive an address on one chain from an address on another chain, you may derive an address that the user cannot actually sign for if the two chains have different address-derivation processes. For example, if you derive a Cosmos address from an Ethereum address, you will get an address that the user cannot sign for and thus risk lost tokens.

</Warning>

### 5\. Execute the route!

Finally, use the `SkipClient.executeRoute` method to create, sign, submit, and track the transaction.

Include optional callbacks on broadcast, track and completion to update your UI as the transaction progresses.

```ts
await skipClient.executeRoute({
  route,
  userAddresses,
  // Executes after all of the operations triggered by a user's signature complete.
  // For multi-tx routes that require multiple user signatures, this will be called once for each tx in sequence
  onTransactionCompleted: (chainID, txHash, status) => {
    console.log(
      `Route completed with tx hash: ${txHash} & status: ${status.state}`
    );
  },
  // called after the transaction that the user signs gets broadcast on chain
  onTransactionBroadcast: ({ txHash, chainID }) => {
    console.log(`Transaction broadcasted with tx hash: ${txHash}`);
  },
  // called after the transaction that the user signs is successfully registered for tracking
  onTransactionTracked: ({ txHash, chainID }) => {
    console.log(`Transaction tracked with tx hash: ${txHash}`);
  },
});
```

Once the transaction is complete, you'll have new TIA in your Celestia address!

 <Check>
**Need Help or Have Feedback?**

Join [our Discord](https://skip.build/discord) and select the "Skip Go Developer" role to share your questions and feedback.

 </Check>
