---
title: 'Getting Started'
description: 'Basic documentation for `@skip-go/client`, a TypeScript package that simplifies interaction with the Skip Go API'
---

## Set up the Library

Install the library in your TypeScript project using npm or yarn:

```Shell Shell
npm install @skip-go/client
```

## Initialize Client

To start your integration, initialize a client (`@skip-go/client.SkipClient`).

This client helper objects wraps interactions with the API and provides useful helper methods for a variety of common actions. You can query assets and chains, construct a route, construct + sign a transaction from a message.

```TypeScript TypeScript
import { SkipClient } from "@skip-go/client";

// Initialize the client with default values and no signers
const client = new SkipClient();
```

The client constructor takes an _optional_ config provided by `SkipClientOptions`:

- `apiURL?: string`: Override the default production URL for interacting with the Skip Go API
- `getEVMSigner?: (chainID: string) => Promise<WalletClient>`: Method that `SkipClient` calls internally whenever it needs a client for constructing and signing an EVM transaction. (`WalletClient` is defined in `viem` and other popular EVM client libraries)
- `getCosmosSigner?: (chainID: string) => Promise<OfflineSigner>`: Method that `SkipClient` calls internally whenever it needs a client for constructing and signing a Cosmos transaction. (`OfflineSigner` is defined in `@cosmjs/proto-signing`)
- `getSVMSigner?: () => Promise<Adapter>`: Method that `SkipClient` calls internally whenever it needs a client for constructing and signing Solana transactions. (`Adapter` is defined in `@solana/wallet-adapter-base`)
- `endpointOptions`:
  - `endpoints?: Record<string, clientTypes.EndpointOptions>`: A map of `chainIDs` to their respective endpoints.
     `clientTypes.EndpointOptions` includes `rpc` and `rest` fields. Note: if you implement this, you do not need to implement the two getter functions below
  - `getRpcEndpointForChain?: (chainID: string) => Promise<string>`: A function that returns the RPC endpoint for a given `chainID`
  - `getRestEndpointForChain?: (chainID: string) => Promise<string>`: A function that returns the REST endpoint for a given `chainID`
- `aminoTypes?: AminoConverters`: additional amino types to be used in the router
- `registryTypes?: Iterable<[string, GeneratedType]>`: additional registry types to be used in the router

## Setup Signers

Optionally, you can set up a signer for each EVM, SVM, or Cosmos SDK ecosystems. This is required for executing transactions.   

For EVM transactions, install the `viem` package:

```Shell shell
npm i viem
```

For SVM transactions, select a wallet adapter from [@solana/wallet-adapter-wallets](https://github.com/anza-xyz/wallet-adapter/blob/master/PACKAGES.md#wallets).
This example uses the Phantom wallet adapter:

```Shell shell
npm i @solana/wallet-adapter-phantom
```

Now, let's create the `SkipClient` instance with the signers from each ecosystem!

We are going to use Keplr for Cosmos transactions, MetaMask for EVM transactions, and Phantom for Solana transactions.

```ts
import { SkipClient } from '@skip-router/client';
import { PhantomWalletAdapter } from '@solana/wallet-adapter-phantom';
import { createWalletClient } from 'viem';

const skipClient = new SkipClient({
  getCosmosSigner: async (chainID) => {
    // get Keplr signer from window object
    const offlineSigner = window.keplr?.getOfflineSigner(chainID);
    if (!offlineSigner) throw new Error('Keplr not installed');
    return offlineSigner;
  },
  getEVMSigner: async () => {
    const ethereum = window.ethereum;
    if (!ethereum) throw new Error('MetaMask not installed');
    const client = createWalletClient({
      chain: mainnet,
      transport: custom(window.ethereum),
    });
    return client;
  },
  getSVMSigner: async () => {
    const phantom = new PhantomWalletAdapter();
    return phantom;
  },
});
```

## Query Basic Info

Now that your client is initialized, you can use it to query basic information about chains & assets to populate your user interface.

#### Get a list of chains

Return type of `client.chains` will be `Chain[]`

```ts
// get a Chain[] of all supported cosmos chains
const chains = await client.chains();
// include EVM, SVM and testnets chains
const chains = await client.chains({
  includeEVM: true,
  includeSVM: true,
  includeTestnets: true,
});
```

#### Get a map of assets by chain ID

Return type of `client.assets` will be `Record<string, Asset[]>`

```ts
// get all chains assets
const assets = await client.assets({
  includeEvmAssets: true,
  includeCW20Assets: true,
  includeSvmAssets: true,
});

// get assets filtered by chain ID
const assets = await client.assets({
  chainID: 'cosmoshub-4'
  includeEvmAssets: true,
  includeCW20Assets: true,
  includeSvmAssets: true,
})
```

## Get a Recommended Asset

Use the `recommendAssets` method to identify the best routes for transferring assets between chains. This method is particularly useful for determining the best asset to receive on the destination chain. These recommendations are based on factors such as liquidity, token denominations, and the unique properties of each IBC transfer route.

Usage example:

```ts
// Pass a single object or an array of objects
const request = [
    {
      sourceAssetDenom: 'uusdc',
      sourceAssetChainID: 'axelar-dojo-1',
      destChainID: 'cosmoshub-4',
    },
    {
      sourceAssetDenom: 'uusdc',
      sourceAssetChainID: 'axelar-dojo-1',
      destChainID: 'osmosis-1',
    },
]

const recommendations = await client.recommendAssets(request);
```

Response example:

```ts
[
  {
    "recommendations": [
      {
        "asset": {
          "denom": "ibc/932D6003DA334ECBC5B23A071B4287D0A5CC97331197FE9F1C0689BA002A8421",
          "chainID": "cosmoshub-4",
          "originDenom": "uusdc",
          "originChainID": "axelar-dojo-1",
          "trace": "transfer/channel-293",
          "isCW20": false,
          "isEVM": false,
          "isSVM": false,
          "symbol": "USDC",
          "name": "USDC",
          "logoURI": "https://raw.githubusercontent.com/cosmos/chain-registry/master/axelar/images/usdc.png",
          "decimals": 6,
          "description": "Circle's stablecoin on Axelar",
          "coingeckoID": "axlusdc",
          "recommendedSymbol": "USDC.axl"
        },
        "reason": "MOST_LIQUID"
      }
    ]
  },
  {
    "recommendations": [
      {
        "asset": {
          "denom": "ibc/D189335C6E4A68B513C10AB227BF1C1D38C746766278BA3EEB4FB14124F1D858",
          "chainID": "osmosis-1",
          "originDenom": "uusdc",
          "originChainID": "axelar-dojo-1",
          "trace": "transfer/channel-208",
          "isCW20": false,
          "isEVM": false,
          "isSVM": false,
          "symbol": "USDC",
          "name": "USDC",
          "logoURI": "https://raw.githubusercontent.com/cosmos/chain-registry/master/axelar/images/usdc.png",
          "decimals": 6,
          "description": "Circle's stablecoin on Axelar",
          "coingeckoID": "axlusdc",
          "recommendedSymbol": "USDC.axl"
        },
        "reason": "MOST_LIQUID"
      }
    ]
  }
]
```

## Get a Route

Once your user has selected source and destination tokens and chains, you can use the client to generate a route and quote:

```ts
const route = await client.route({
  amountIn: "1000000",
  sourceAssetDenom: "ibc/932D6003DA334ECBC5B23A071B4287D0A5CC97331197FE9F1C0689BA002A8421",
  sourceAssetChainID: "axelar-dojo-1",
  destAssetDenom: "uosmo",
  destAssetChainID: "osmosis-1",
  cumulativeAffiliateFeeBPS: '0',
});
```

## Get Required Addresses

Now that we have the route response, we can use our signer to get the list of chains where the user or reeceiver addresses are required for executing the route.

We'll use these addresses in the next step to populate `userAddresses` when executing the route with the `SkipClient.executeRoute` method.

The `requiredChainAddresses` field in the output of `route` gives the chainIDs we need to use.

 <Warning>
 **Use addresses your user can sign with**

Funds could end up in any of the addresses you provide -- including intermediate chains in certain failure conditions (e.g. an IBC tranfer timesout after a swap). So you must be sure your user can sign for each address you provide.

See [Cross-chain Failure Cases](../advanced-transfer/handling-cross-chain-failure-cases) for more details on when funds might end up in an intermediate address.

(Rest assured that `SkipClient.transactionStatus` will tell you where your users funds end up even if they don't make it to their final destination.)

</Warning>

It's recommended you keep the address somewhere and have function to get the address from the chainID. In this example we have a function called `getAddress` that takes the chainID and returns the address.

Add the following snippet to your script after getting the route to retrieve the address associated with each `requiredChainAddresses` entry:

```Javascript
// get user addresses for each requiredChainAddress
    const userAddresses = await Promise.all(route.requiredChainAddresses.map(async (chainID) => {
        return {
            chainID: chainID,
            address: await getAddress(chainID)
        }
    }))
```

## Execute a Route

Once you have a route, you can execute it in a single function call (passing in the route, the user addresses for at least the chains the route includes, and an optional callback function.

For example:

```ts
await client.executeRoute({
  route,
  userAddresses: USER_ADDRESSES,
  onTransactionSuccess: async (chainID, txHash, success) => {
    console.log(txHash);
  },
});
```

For routes that consist of multiple transactions, this will monitor each transaction until it completes, then generate the transaction for the next step and prompt the user to sign it.

_Alternatively, you can use the route to generate, sign, and submit the messages separately -- or use your own solutions for any/all of these steps if you like. See `SkipClient.messages`, `SkipClient.signMultiChainMessageDirect`, and `SkipClient.submitTransaction` for details on these lower-level functions_

## Cross-chain Transaction Tracking

Once the user has signed a transaction to execute a cross-chain action, you can track it using the `SkipClient` functions:

- `SkipClient.trackTransaction`: Requests tracking for a that's already been submitted to the network through an RPC, using the transaction hash
- `SkipClient.submitTransaction`: Publishes the signed transaction to the network & begins tracking the cross-chain actions this transaction produces

After you've used one of these two functions to kick-off realtime tracking for a cross-chain action, you can request the current status of the transaction using `SkipClient.transactionStatus`.

We also provide a `waitForTransaction` helper function that hangs until the entire cross-chain action flow has completed, which you can use instead of configuring your own polling via `transactionStatus`

 <Check>
 **Want to help us get better? Have questions or feedback?**

You can reach us easily by joining [our Discord](https://skip.build/discord) and grabbing the "Skip Go Developer" role.

 </Check>
