---
title: 'Getting Started'
description: '@skip-go/client is a TypeScript library that streamlines interaction with the Skip Go API, enabling cross-chain swaps and transfers across multiple ecosystems.'
---
<Info>
Anxious to get started? See a live example of this [code](https://github.com/skip-mev/skip-go-example) in our [example app](https://skip-next-simple-example.vercel.app/). 
</Info>
<Steps> 
<Step title="Install Library">

Install the library using npm or yarn:

<CodeGroup>
```Shell npm
npm install @skip-go/client
```
```Shell yarn
yarn add @skip-go/client
```
</CodeGroup>

<Info>
If you're using `yarn` (or another package manager that doesn't install peer dependencies by default)
you may need to install these peer dependencies as well:

```bash
  yarn add viem @solana/web3.js
```
</Info>

</Step> <Step title="Initialize Library">

To start integrating with the Skip Go API, you no longer initialize a `SkipClient` instance. Instead, you configure the library once and then import and use individual functions directly.

### Initialization Options

- **If using `executeRoute`:** Call `setClientOptions()` once at application startup with your configuration (excluding signers).
- **If *not* using `executeRoute`:** Call `setApiOptions({ apiUrl, apiKey })` once at startup, or pass `apiUrl` and `apiKey` to each function call.

```ts Import and Initialize
import {
  setClientOptions, // Use if calling executeRoute
  setApiOptions,    // Use if *not* calling executeRoute
  chains,
  assets,
  route,
  executeRoute,
  // ... other functions you need
} from "@skip-go/client";

// Example: Initialize for executeRoute usage
setClientOptions({
  endpointOptions: { /* ... */ },
  // ... other options like aminoTypes, registryTypes
});

// Example: Initialize for direct API calls (no executeRoute)
setApiOptions({
  apiUrl: "YOUR_API_URL", // Optional: defaults to Skip API
  apiKey: "YOUR_API_KEY",   // Optional: required for certain features
});

// Now you can call functions directly, e.g.:
// const supportedChains = await chains();
```

### Configuration Parameters

- `apiUrl?: string`: Override the default API URL (used by `setApiOptions` or passed directly).
- `apiKey?: string`: Your Skip API key (used by `setApiOptions` or passed directly).
- `endpointOptions?: EndpointOptions`: Provide RPC and REST endpoints for specific chains (used by `setClientOptions`).
- `aminoTypes?: AminoConverters`: Additional amino types for message encoding (used by `setClientOptions`).
- `registryTypes?: Iterable<[string, GeneratedType]>`: Additional registry types (used by `setClientOptions`).

</Step> <Step title="Setup Signers">

To execute transactions, you need to set up signers for the ecosystems you plan to interact with. Below are examples for Cosmos SDK, EVM, and Solana (SVM). Note that for EVM and SVM, you'll need to install additional libraries.

### Signer Setup
<CodeGroup>

```ts Cosmos Signer
// For Cosmos transactions, we'll use Keplr wallet from the window object
const getCosmosSigner = async (chainId: string) => {
  const key = await window.keplr?.getKey(chainId);
  if (!key) throw new Error("Keplr not installed or chain not added");

  return key.isNanoLedger
        ? window.keplr?.getOfflineSignerOnlyAmino(chainId)
        : window.keplr?.getOfflineSigner(chainId);
};

```

```ts EVM Signer
// For EVM transactions, we'll use MetaMask and viem
// npm install viem
import { createWalletClient, custom, Account } from "viem";
import { mainnet } from 'viem/chains';

const getEvmSigner = async () => {
  const ethereum = window.ethereum;
  if (!ethereum) throw new Error("MetaMask not installed");
  const accounts = await ethereum.request({ method: 'eth_requestAccounts' }) as Account[];
  const account = accounts?.[0]
  if (!account) throw new Error('No accounts found');
  const client = createWalletClient({
    account,
    chain: mainnet,
    transport: custom(window.ethereum),
  });
  return client;
}
```

```ts SVM Signer
// For Solana transactions, we'll use the Phantom wallet adapter
// npm install @solana/wallet-adapter-phantom
import { PhantomWalletAdapter } from '@solana/wallet-adapter-phantom';

const getSvmSigner = async () => {
  const phantom = new PhantomWalletAdapter();
  await phantom.connect();
  return phantom;
};
```
</CodeGroup>

### Using Signers

These signer functions (`getCosmosSigner`, `getEvmSigner`, `getSvmSigner`) are **not** passed during initialization with `setClientOptions`.

Instead, you pass them directly to the `executeRoute` function when you are ready to execute a transaction, as shown in Step 7.

</Step> <Step title="Query Basic Info">

With the library initialized, you can query balances, supported chains and assets using the imported functions.

### Query Examples

<CodeGroup>

```ts Supported Chains
import { chains } from "@skip-go/client";

// returns a Chain[] of all supported Cosmos mainnet chains
const cosmosChains = await chains();

// include EVM and SVM chains
const allChains = await chains({
  includeEVM: true,
  includeSVM: true,
});

// only show testnet chains
const testnetChains = await chains({
  onlyTestnets: true
});
```

```ts Supported Assets
import { assets } from "@skip-go/client";

// returns `Record<string, Asset[]>`, includes EVM & SVM by default
const allAssets = await assets();

// get assets filtered by chain ID
const cosmosHubAssets = await assets({
  chainId: 'cosmoshub-4',
  includeCw20Assets: true, // include Cw20 assets for this chain
});

// only get assets for specific chains
const specificAssets = await assets({
  chainIds: ['osmosis-1', '1'], // Ethereum and Osmosis
});
```

```ts Token Balances
import { balances } from "@skip-go/client";

// Define the request structure
interface BalancesRequest {
  chainId: string;
  address: string;
  denoms?: string[]; // Optional: specify denoms, otherwise fetches all
}

const balanceRequests: BalancesRequest[] = [
  {
    chainId: "137", // Polygon
    address: "0x24a9267cE9e0a8F4467B584FDDa12baf1Df772B5",
    denoms: [
      "polygon-native", // Matic
      "0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359" // USDC
    ]
  },
  {
    chainId: "osmosis-1",
    address: "osmo12xufazw43lanl8dkvf3l7y9zzm8n3zswftw2yc",
    denoms: ["uosmo"]
  }
];

// returns a map of assets by chain ID
const userBalances = await balances({ requests: balanceRequests });
```
</CodeGroup>

</Step> <Step title="Get a Route">

Once you've selected your source and destination chains and tokens, you can generate a route and get a quote using the `route` function. See it in context [here](https://github.com/skip-mev/skip-go-example/blob/d68ec668ebaa230325ad31658b547bd27c42ac49/pages/index.tsx#L46).

### Route Examples

<CodeGroup>
```ts Swap ATOM for OSMO Example
import { route } from "@skip-go/client";

const routeResult = await route({
  amountIn: "1000000", // Desired amount in smallest denomination (e.g., uatom)
  sourceAssetDenom: "uatom",
  sourceAssetChainID: "cosmoshub-4",
  destAssetDenom: "uosmo",
  destAssetChainID: "osmosis-1",
  cumulativeAffiliateFeeBPS: '0',
});
```
```ts Swap ETH for TIA Example
import { route } from "@skip-go/client";

const routeResult = await route({
  amountOut: "1000000", // Desired amount out
  sourceAssetDenom: "ethereum-native",
  sourceAssetChainID: "1", // Ethereum mainnet chain ID
  destAssetDenom: "utia",
  destAssetChainID: "celestia",
  smartRelay: true,
  smartSwapOptions: {
    splitRoutes: true,
    evmSwaps: true
  },
});
```
```ts Transfer USDC from Solana to Noble Example
import { route } from "@skip-go/client";

const routeResult = await route({
  sourceAssetDenom: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
  sourceAssetChainID: "solana",
  destAssetDenom: "uusdc",
  destAssetChainID: "noble-1",
  amountIn: "1000000",
  smartRelay: true
});
      ```
</CodeGroup>

<Info>
  Read more about [affiliate fees](../general/affiliate-fees), [Smart Relay](../general/smart-relay) and [EVM Swaps](../advanced-swapping/smart-swap-options#feature-evm-swaps).
</Info>

</Step> <Step title="Get Required Addresses">

After generating a route, you need to provide user addresses for the required chains. The `route.requiredChainAddresses` array lists the chain IDs for which addresses are needed.

 <Warning>
 **Only use addresses your user can sign for.**
 Funds could get stuck in any address you provide, including intermediate chains in certain failure conditions. Ensure your user can sign for each address you provide. 
See [Cross-chain Failure Cases](../advanced-transfer/handling-cross-chain-failure-cases) for more details.
</Warning>

We recommend storing the user's addresses and creating a function like [`getAddress`](https://github.com/skip-mev/skip-go-example/blob/c55d9208bb46fbf1a4934000e7ec4196d8ccdca4/pages/index.tsx#L99) that retrieves the address based on the chain ID. 

```ts
// get user addresses for each requiredChainAddress to execute the route
  const userAddresses = await Promise.all(
  routeResult.requiredChainAddresses.map(async (chainId) => ({
    chainId,
    address: await getAddress(chainId),
  }))
);
```

</Step> <Step title="Execute the Route">

Once you have a route object (`routeResult` from the previous step), you can execute it using the `executeRoute` function. You need to pass the route object, the user addresses, and the necessary signer functions.

### Execute Route Example

```ts Execute Route
import {
  executeRoute,
  // Import your signer functions defined in Step 3
  getCosmosSigner,
  getEvmSigner,
  getSvmSigner,
} from "@skip-go/client";

// Assuming 'routeResult' holds the object from the route() call
// Assuming 'userAddresses' holds the array from the 'Get Required Addresses' step

await executeRoute({
  route: routeResult,
  userAddresses,
  getCosmosSigner, // Pass the signer functions directly
  getEvmSigner,
  getSvmSigner,
  // Optional Callbacks
  onTransactionCompleted: async (chainId, txHash, status) => {
    console.log(
      `Route completed on chain ${chainId} with tx hash: ${txHash} & status: ${status.state}`
    );
  },
  onTransactionBroadcast: async ({ txHash, chainId }) => {
    console.log(`Transaction broadcasted on ${chainId} with tx hash: ${txHash}`);
  },
  onTransactionTracked: async ({ txHash, chainId }) => {
    console.log(`Transaction tracked for ${chainId} with tx hash: ${txHash}`);
  },
  onTransactionSigned: async ({ txHash, chainId }) => {
    console.log(`Transaction signed for ${chainId} with tx hash: ${txHash}`);
  },
  onValidateGasBalance: async ({ chainId, isGasSufficient }) => {
    if (!isGasSufficient) {
      console.warn(`Insufficient gas balance on chain ${chainId}.`);
      // Optionally prompt user to acquire more gas
    }
  },
});
```

For routes that consist of multiple transactions, `executeRoute` will monitor each transaction until it completes, then generate the transaction for the next step and prompt the user to sign it using the appropriate signer.

<Info>
Alternatively, you can handle message generation, signing, and submission manually using the individual functions:
- `messages`: Generate transaction messages.
- `signDirect`: Sign messages directly.
- `broadcastTx`: Broadcast transactions to the network.
- `submitTransaction`: Submit and track transactions.
Refer to the API documentation for details on these lower-level functions.
</Info>

</Step> <Step title="Transaction Tracking">

Once the user has signed a transaction to execute a cross-chain action, you can track its progress.

### Tracking Transactions

If you used `executeRoute`, tracking is handled automatically. For manual transaction submission or to track an existing transaction:

- **Track Existing Transaction:** `trackTransaction` - Call this function with a `txHash` and `chainId` to begin Skip's backend tracking for a transaction already submitted to the network.
- **Submit and Track:** `submitTransaction` - This function (used internally by `executeRoute`) submits a signed transaction to the network *and* registers it for tracking.

After a transaction is registered for tracking (either via `executeRoute`, `submitTransaction`, or `trackTransaction`), you can poll for its status:

- **Check Status:** `transactionStatus` - Takes a `txHash` and `chainId` and returns the current cross-chain status.

We also provide a `waitForTransaction` helper function (imported from `@skip-go/client`) that resolves a promise when the entire cross-chain action flow has completed. This can be an alternative to manually polling with `transactionStatus`.

```ts Manual Transaction Tracking
import {
  submitTransaction,
  trackTransaction,
  transactionStatus,
  waitForTransaction
} from "@skip-go/client";

async function handleManualTx(signedTx: any, chainId: string) {

  const { txHash } = await submitTransaction({
    signedTx: signedTx.tx_bytes, // Or however your signed tx is structured
    chainId: chainId,
  });
  console.log(`Submitted and tracking tx: ${txHash} on ${chainId}`);

  // Or, if already submitted elsewhere:
  // await trackTransaction({ txHash: existingTxHash, chainId });


  const checkStatus = async () => {
    const status = await transactionStatus({ txHash, chainId });
    console.log("Current status:", status.state);
    // Check if the transaction is in a terminal state
    if (status.state !== "COMPLETED" && status.state !== "ABANDONED" /* ... add other terminal states */) { 
      setTimeout(checkStatus, 5000); 
    } else {
      console.log("Final status:", status);
    }
  };
  //checkStatus(); // Uncomment to start polling

  // Or, use the helper to wait for completion
  try {
    const finalStatus = await waitForTransaction({ txHash, chainId });
    console.log("Transaction completed:", finalStatus);
  } catch (error) {
    console.error("Error waiting for transaction or transaction failed:", error);
  }
}
```

</Step> 

<Info>
**Have questions or feedback? Help us get better!**

Join [our Discord](https://skip.build/discord) and select the "Skip Go Developer" role to share your questions and feedback.
</Info>

</Steps>
