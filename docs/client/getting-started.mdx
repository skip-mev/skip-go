---
title: 'Getting Started'
description: '@skip-go/client is a TypeScript library that streamlines interaction with the Skip Go API, enabling cross-chain swaps and transfers across multiple ecosystems. This guide will help you set up the library, initialize the client, and walk you through examples for Cosmos SDK, EVM, and Solana.'
---

## 1. Install Library

Install the library in your TypeScript project using npm or yarn:

```Shell Shell
npm install @skip-go/client
```

## 2. Initialize Client

To start integrating with the Skip Go API, initialize a `SkipClient` instance. This `skipClient` provides helper methods for common actions such as querying assets and chains, constructing routes, and executing transactions.

```ts
import { SkipClient } from "@skip-go/client";

const client = new SkipClient({
  // Signers will be set up in the following sections
});
```

The SkipClient constructor accepts an optional configuration object of type `SkipClientOptions`. Here's a brief overview:

- `apiURL?: string`: Override the default API URL
- `endpointOptions?: EndpointOptions`: Provide RPC and REST endpoints for specific chains
- `aminoTypes?: AminoConverters`: Additional amino types to be for message encoding
- `registryTypes?: Iterable<[string, GeneratedType]>`: Additional registry types 

## 3. Setup Signers

To execute transactions, you need to set up signers for the ecosystems you plan to interact with. Below are examples for Cosmos SDK, EVM, and Solana (SVM).

### Cosmos SDK

For Cosmos transactions, we'll use the **Keplr** wallet.

```ts

// Ensure Keplr is installed and accessible
const getCosmosSigner = async (chainID: string) => {
  const offlineSigner = await window.keplr?.getOfflineSigner(chainID);
  if (!offlineSigner) throw new Error("Keplr not installed or chain not added");
  return offlineSigner;
};

```
### EVM Signer

For EVM transactions, we'll use **MetaMask** and the `viem` library.

First, install `viem`:

```Shell shell
npm i viem
```

Then create the signer: 

```ts
import { createWalletClient, custom } from 'viem';
import { mainnet } from 'viem/chains';

const getEVMSigner = async () => {
  const ethereum = window.ethereum;
  if (!ethereum) throw new Error("MetaMask not installed");
  const client = createWalletClient({
    chain: mainnet,
    transport: custom(window.ethereum),
  });
  return client;
};
```

### Solana (SVM) Signer

For Solana transactions, we'll use the **Phantom** wallet adapter.

First, install the Phantom wallet adapter:

```shell
npm install @solana/wallet-adapter-phantom
```

Set up the SVM signer:

```ts
import { PhantomWalletAdapter } from '@solana/wallet-adapter-phantom';

const getSVMSigner = async () => {
  const phantom = new PhantomWalletAdapter();
  await phantom.connect();
  return phantom;
};
```
### Finalizing the Client Initialization
Now, pass the signers into your SkipClient instance:

```ts
const skipClient = new SkipClient({
  getCosmosSigner,
  getEVMSigner,
  getSVMSigner,
});
```

## 4. Query Basic Info

With your client initialized, you can query supported chains and assets.

### Get a List of Chains

```ts
// returns a Chain[] of all supported Cosmos mainnet chains
const cosmosChains = await skipClient.chains();

// include EVM and SVM chains
const allChains = await skipClient.chains({
  includeEVM: true,
  includeSVM: true,
});

// only show testnet chains
const testnetChains = await skipClient.chains({
  onlyTestnets: true
});
```

#### Get a map of assets by chain ID

Return type will be `Record<string, Asset[]>`

```ts
// returns `Record<string, Asset[]>
const assets = await skipClient.assets({
  includeEvmAssets: true,
  includeSvmAssets: true,
});

// get assets filtered by chain ID
const assets = await client.assets({
  chainID: 'cosmoshub-4'
  includeCW20Assets: true,
})
```

## 5. Get a Route

Once you've selected your source and destination chains and tokens, you can generate a route and get a quote.


```ts
// Example: Swap 1 ATOM on Cosmos Hub to OSMO on Osmosis
const route = await skipClient.route({
  amountIn: "1000000", // Desired amount in smallest denomination (e.g., uatom)
  sourceAssetDenom: "uatom",
  sourceAssetChainID: "cosmoshub-4",
  destAssetDenom: "uosmo",
  destAssetChainID: "osmosis-1",
  cumulativeAffiliateFeeBPS: '0',
});

// Example: Swap ETH on Ethereum to 1 TIA on Celestia
const route = await skipClient.route({
  amountOut: "1000000", // Desired amount out
  sourceAssetDenom: "ethereum-native",
  sourceAssetChainID: "1", // Ethereum mainnet chain ID
  destAssetDenom: "utia",
  destAssetChainID: "celestia",
  smartRelay: true,
});
```

<Info>
  Read more about [affiliate fees](../general/affiliate-fees) and [Smart Relay](../general/smart-relay).
</Info>

## 6. Get Required Addresses

After generating a route, you need to provide user addresses for the required chains. The `route.requiredChainAddresses` array lists the chain IDs for which addresses are needed.

 <Warning>
 **Only use addresses your user can sign for**
 Funds could get stuck in any address you provide, including intermediate chains in certain failure conditions. Ensure your user can sign for each address you provide. 
See [Cross-chain Failure Cases](../advanced-transfer/handling-cross-chain-failure-cases) for more details.
</Warning>

We recommend storing the user's addresses and creating a function like `getAddress` that retrieves the address based on the chain ID.

```ts
// get user addresses for each requiredChainAddress to execute the route
  const userAddresses = await Promise.all(
  route.requiredChainAddresses.map(async (chainID) => ({
    chainID,
    address: await getAddress(chainID),
  }))
);
```

## 7. Execute the Route

Once you have a route, you can execute it in a single function call (passing in the route, the user addresses for at least the chains the route includes, and an optional callback function:

```ts
await skipClient.executeRoute({
  route,
  userAddresses,
  // Executes after all of the operations triggered by a user's signature complete.
  // For multi-tx routes that require multiple user signatures, this will be called once for each tx in sequence
  onTransactionCompleted: (chainID, txHash, status) => {
    console.log(
      `Route completed with tx hash: ${txHash} & status: ${status.state}`
    );
  },
  // called after the transaction that the user signs gets broadcast on chain
  onTransactionBroadcast: ({ txHash, chainID }) => {
    console.log(`Transaction broadcasted with tx hash: ${txHash}`);
  },
  // called after the transaction that the user signs is successfully registered for tracking
  onTransactionTracked: ({ txHash, chainID }) => {
    console.log(`Transaction tracked with tx hash: ${txHash}`);
  },
});
```

For routes that consist of multiple transactions, this will monitor each transaction until it completes, then generate the transaction for the next step and prompt the user to sign it.

_Alternatively, you can use the route to generate, sign, and submit the messages separately -- or use your own solutions for any/all of these steps if you like. See `skipClient.messages`, `skipClient.signMultiChainMessageDirect`, and `skipClient.submitTransaction` for details on these lower-level functions_

## 8. Track the Transaction 

Once the user has signed a transaction to execute a cross-chain action, you can track it using the `SkipClient` functions:

- `skipClient.trackTransaction`: Requests tracking for a that's already been submitted to the network through an RPC, using the transaction hash
- `skipClient.submitTransaction`: Publishes the signed transaction to the network & begins tracking the cross-chain actions this transaction produces

After you've used one of these two functions to kick-off realtime tracking for a cross-chain action, you can request the current status of the transaction using `skipClient.transactionStatus`.

We also provide a `waitForTransaction` helper function that hangs until the entire cross-chain action flow has completed, which you can use instead of configuring your own polling via `transactionStatus`.

 <Check>
 **Have questions or feedback? Help us get better!**

Join [our Discord](https://skip.build/discord) and select the "Skip Go Developer" role to share your questions and feedback.

 </Check>
