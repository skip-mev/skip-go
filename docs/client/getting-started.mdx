---
title: 'Getting Started'
description: 'Basic documentation for `@skip-go/client`, a TypeScript package that simplifies interaction with the Skip Go API'
---

## Set up the Library

Install the library in your TypeScript project using npm or yarn:

```Shell Shell
npm install @skip-go/client
```

## Initialize Client

To start your integration, initialize a client (`@skip-go/client.SkipClient`).

This client helper objects wraps interactions with the API and provides useful helper methods for a variety of common actions. You can query assets and chains, construct a route, construct + sign a transaction from a message.

```TypeScript TypeScript
import { SkipClient } from "@skip-go/client";

// See options and signers setup below
const client = new SkipClient({
  ...config, // optional config 
  ...signers // signers required for executing transactions
});
```

The client constructor takes an _optional_ config provided by `SkipClientOptions`:

- `apiURL?: string`: Override the default production URL for interacting with the Skip Go API
- `getEVMSigner?: (chainID: string) => Promise<WalletClient>`: Method that `SkipClient` calls internally whenever it needs a client for constructing and signing an EVM transaction. (`WalletClient` is defined in `viem` and other popular EVM client libraries)
- `getCosmosSigner?: (chainID: string) => Promise<OfflineSigner>`: Method that `SkipClient` calls internally whenever it needs a client for constructing and signing a Cosmos transaction. (`OfflineSigner` is defined in `@cosmjs/proto-signing`)
- `getSVMSigner?: () => Promise<Adapter>`: Method that `SkipClient` calls internally whenever it needs a client for constructing and signing Solana transactions. (`Adapter` is defined in `@solana/wallet-adapter-base`)
- `endpointOptions`:
  - `endpoints?: Record<string, clientTypes.EndpointOptions>`: A map of `chainIDs` to their respective endpoints.
     `clientTypes.EndpointOptions` includes `rpc` and `rest` fields. Note: if you implement this, you do not need to implement the two getter functions below
  - `getRpcEndpointForChain?: (chainID: string) => Promise<string>`: A function that returns the RPC endpoint for a given `chainID`
  - `getRestEndpointForChain?: (chainID: string) => Promise<string>`: A function that returns the REST endpoint for a given `chainID`
- `aminoTypes?: AminoConverters`: additional amino types to be used in the router
- `registryTypes?: Iterable<[string, GeneratedType]>`: additional registry types to be used in the router

## Setup Signers

Optionally, you can set up a signer for each EVM, SVM, or Cosmos SDK ecosystems. This is required for executing transactions.   

For EVM transactions, install the `viem` package:

```Shell shell
npm i viem
```

For SVM transactions, select a wallet adapter from [@solana/wallet-adapter-wallets](https://github.com/anza-xyz/wallet-adapter/blob/master/PACKAGES.md#wallets).
This example uses the Phantom wallet adapter:

```Shell shell
npm i @solana/wallet-adapter-phantom
```

Now, let's create the `SkipClient` instance with the signers from each ecosystem!

We are going to use Keplr for Cosmos transactions, MetaMask for EVM transactions, and Phantom for Solana transactions. Note that some signers require access to the window browswer object.

```ts
import { SkipClient } from '@skip-router/client';
import { PhantomWalletAdapter } from '@solana/wallet-adapter-phantom';
import { createWalletClient } from 'viem';

const skipClient = new SkipClient({
  getCosmosSigner: async (chainID) => {
    const offlineSigner = window.keplr?.getOfflineSigner(chainID);
    if (!offlineSigner) throw new Error('Keplr not installed');
    return offlineSigner;
  },
  getEVMSigner: async () => {
    const ethereum = window.ethereum;
    if (!ethereum) throw new Error('MetaMask not installed');
    const client = createWalletClient({
      chain: mainnet,
      transport: custom(window.ethereum),
    });
    return client;
  },
  getSVMSigner: async () => {
    const phantom = new PhantomWalletAdapter();
    return phantom;
  },
});
```

## Query Basic Info

Now that your client is initialized, you can use it to query chains & assets supported by Skip Go.

#### Get a List of Chains

```ts
// returns a Chain[] of all supported Cosmos mainnet chains
const cosmosChains = await client.chains();

// include EVM and SVM chains
const allChains = await client.chains({
  includeEVM: true,
  includeSVM: true,
});

// only show testnet chains
const testnetChains = await client.chains({
  onlyTestnets: true
});
```

#### Get a Map of assets by Chain ID

```ts
// returns `Record<string, Asset[]>
const assets = await client.assets({
  includeEvmAssets: true,
  includeSvmAssets: true,
});

// filter assets by chain ID
const hubAssets = await client.assets({
  chainID: 'cosmoshub-4',
  includeCW20Assets: true,
})
```

## Get a Route

Once you've established source/destination chains and tokens, you can use the client to generate a route and quote. You can specify either `amountIn` or `amountOut` but not both:

```ts
// 1 ATOM on Cosmos Hub to OSMO on Osmosis
const route = await client.route({
  amountIn: "1000000",
  sourceAssetDenom: "uatom",
  sourceAssetChainID: "cosmoshub-4",
  destAssetDenom: "uosmo",
  destAssetChainID: "osmosis-1",
  cumulativeAffiliateFeeBPS: '0',
});

// ETH on Ethereum to 1 TIA on Celestia
const route = await client.route({
  amountOut: "1000000",
  sourceAssetDenom: "ethereum-native",
  sourceAssetChainID: "1",
  destAssetDenom: "utia",
  destAssetChainID: "celestia",
  smartRelay: true,
});
```

<Info>
  Read more about [affiliate fees](../general/affiliate-fees) and [Smart Relay](../general/smart-relay).
</Info>

## Get Required Addresses
Now that we have the route, we can use the signer to obtain the receiver addresses for required execution. We'll populate `userAddresses` with these addresses when executing the route using the `SkipClient.executeRoute` method. The chainIDs we need addresses for are provided in the `requiredChainAddresses` field of the route output.

 <Warning>
 **Only use addresses your user can sign for**
Funds could get stuck in any address you provide -- including intermediate chains in certain failure conditions (e.g. an IBC tranfer timesout after a swap). Ensure your user can sign for each address you provide.
See [Cross-chain Failure Cases](../advanced-transfer/handling-cross-chain-failure-cases) for more details on cases when assets may get end up in an intermediate address.
Rest assured that `SkipClient.transactionStatus` will tell you where your users funds end up even if they don't make it to their final destination.
</Warning>

It's recommended to write a function that takes a chainID and returns the address.
Add the following snippet to your script after getting the route to retrieve the address associated with each `requiredChainAddresses` entry:

```ts
// get user addresses for each requiredChainAddress to execute the route
  const userAddresses = route.requiredChainAddresses.map((chainID) => {
    return {
        chainID: chainID,
        address: getAddress(chainID)
    }
  })
```

## Execute a Route

Once you have a route, you can execute it in a single function call (passing in the route, the user addresses for at least the chains the route includes, and an optional callback function:

```ts
await client.executeRoute({
  route: route,
  userAddresses: userAddresses,
  onTransactionSuccess: async (chainID, txHash, success) => {
    console.log(txHash);
  },
});
```

For routes that consist of multiple transactions, this will monitor each transaction until it completes, then generate the transaction for the next step and prompt the user to sign it.

_Alternatively, you can use the route to generate, sign, and submit the messages separately -- or use your own solutions for any/all of these steps if you like. See `SkipClient.messages`, `SkipClient.signMultiChainMessageDirect`, and `SkipClient.submitTransaction` for details on these lower-level functions_

## Cross-chain Transaction Tracking

Once the user has signed a transaction to execute a cross-chain action, you can track it using the `SkipClient` functions:

- `SkipClient.trackTransaction`: Requests tracking for a that's already been submitted to the network through an RPC, using the transaction hash
- `SkipClient.submitTransaction`: Publishes the signed transaction to the network & begins tracking the cross-chain actions this transaction produces

After you've used one of these two functions to kick-off realtime tracking for a cross-chain action, you can request the current status of the transaction using `SkipClient.transactionStatus`.

We also provide a `waitForTransaction` helper function that hangs until the entire cross-chain action flow has completed, which you can use instead of configuring your own polling via `transactionStatus`.

 <Check>
 **Want to help us get better? Have questions or feedback?**

You can reach us easily by joining [our Discord](https://skip.build/discord) and grabbing the "Skip Go Developer" role.

 </Check>
