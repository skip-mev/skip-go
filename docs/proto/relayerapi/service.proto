syntax = "proto3";

package skip.relayer;

option go_package = "github.com/skip-mev/relayer/proto/gen/relayerapi";
import "google/protobuf/timestamp.proto";



service RelayerApiService {
    // VerifyRelayPayment verifies a payment has been recieved on chain for a given transfer, this operation completes
    // asyncronously, and when the payment is verified, the status of the transfer will be updated to PENDING.
    rpc VerifyRelayPayment(VerifyRelayPaymentRequest) returns (VerifyRelayPaymentResponse) {}

    // Relay will track the status of a transfer, and submit the transactions required to complete the transfer via
    // the bridging protocol. The transfer will be updated to PROCESSING until the transfer is completed, or fails.
    rpc Relay(RelayRequest) returns (RelayResponse) {}

    // Status will return the current status of a transfer. PENDING, PROCESSING, COMPLETED, or FAILED. We assume that
    // the status is PENDING for any transaction that has not been verified by the VerifyRelayPayment operation.
    // The status message will be set if the status is FAILED.
    rpc Status(StatusRequest) returns (StatusResponse) {}

    rpc Quote(QuoteRequest) returns (QuoteResponse) {}
}

enum BridgeType {
    BRIDGE_TYPE_UNKNOWN = 0;
    BRIDGE_TYPE_CCTP = 1;
    BRIDGE_TYPE_EUREKA = 2;
}

message FeeAsset {
    string denom = 1;
    string coingecko_id = 2;
    uint32 decimals = 3;
}

message QuoteRequest {
    string source_chain_id = 1;
    string dest_chain_id = 2;
    BridgeType bridge_type = 3;
    FeeAsset fee_asset = 4;
}

message QuoteResponse {
    string payment_amount = 1;
    string payment_address = 2;
    bool payment_address_is_contract = 3;
    google.protobuf.Timestamp expiration = 4;
}

message CCTPInfo {
    repeated SVMSystemAccountTokenAccountPair system_account_token_account_pairs = 1;
}

message NobleForwardingInfo {
    string address = 1;
    string channel = 2;
    string recipient = 3;
}

message SVMSystemAccountTokenAccountPair {
    string system_account = 1;
    string token_account = 2;
    string token_mint_account = 3;
}

message VerifyRelayPaymentRequest {
    string tx_hash = 1;
    string chain_id = 3;
    CCTPInfo cctp_metadata = 4;
    NobleForwardingInfo noble_forwarding_info = 5;
}

message VerifyRelayPaymentResponse {}

message StatusRequest {
    string tx_hash = 1;
}

enum StatusCode {
    UNKNOWN = 0;
    PENDING = 1;
    PROCESSING = 2;
    COMPLETED = 3;

    CHECK_RECV_PACKET_DELIVERY = 4;
    GET_RECV_PACKET = 5;
    DELIVER_RECV_PACKET = 6;
    WAIT_FOR_WRITE_ACK = 7;
    CHECK_ACK_PACKET_DELIVERY = 8;
    GET_ACK_PACKET = 9;
    DELIVER_ACK_PACKET = 10;
    CHECK_TIMEOUT_PACKET_DELIVERY = 11;
    GET_TIMEOUT_PACKET = 12;
    DELIVER_TIMEOUT_PACKET = 13;
    COMPLETE_WITH_ACK = 14;
    COMPLETE_WITH_TIMEOUT = 15;

    FAILED = 16;
}

message StatusResponse {
    StatusCode status_code = 1;
    string status_message = 2;
}

enum ChainEnvironment {
    CHAIN_ENVIRONMENT_UNKNOWN = 0;
    CHAIN_ENVIRONMENT_TESTNET = 1;
    CHAIN_ENVIRONMENT_MAINNET = 2;
}

message RelayRequest {
    string tx_hash = 1;
    TransferInfo transfer_info = 2;
    ChainEnvironment chain_environment = 3;
}

message TransferInfo {
    oneof transfer_info {
        TransferInfoCCTP cctp = 1;
        TransferInfoEureka eureka = 2;
    }
}

message TransferInfoCCTP {
    uint32 source_domain = 1;
    uint32 destination_domain = 2;
    uint64 nonce = 3;
    bytes message_bytes = 4;
    optional string svm_system_account = 5;
    google.protobuf.Timestamp message_sent_tx_time = 6;
    uint64 transfer_amount = 7;

    NobleForwardingInfo noble_forwarding_info = 8;
}

message TransferInfoEureka {
    string source_chain_id = 1;
    string destination_chain_id = 2;
    string packet_source_client_id = 3;
    string packet_destination_client_id = 4;
    uint64 packet_sequence_number = 5;
    google.protobuf.Timestamp packet_timeout_time = 6;
    google.protobuf.Timestamp source_tx_time = 7;
}

message RelayResponse {}
